# live_monitor_worker.py (Ø¨Ø§ ÙØ±Ù…Øª Ù¾ÛŒØ§Ù… ØªÙ„Ú¯Ø±Ø§Ù… Ø§ÙØ³Ø§Ù†Ù‡â€ŒØ§ÛŒ)

import asyncio
import os
import django
import logging
import time
from typing import Dict, Optional, List
from datetime import datetime
import pytz
from jdatetime import datetime as jdatetime

# --- Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ùˆ Ø¶Ø±ÙˆØ±ÛŒ Django ---
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'trading_app.settings')
django.setup()

from core.exchange_fetcher import ExchangeFetcher
from engines.master_orchestrator import MasterOrchestrator
from engines.signal_adapter import SignalAdapter
from engines.telegram_handler import TelegramHandler

# --- ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ØµÙ„ÛŒ Ø±Ø¨Ø§Øª ---
SYMBOLS_TO_MONITOR = ['BTC', 'ETH', 'XRP', 'SOL', 'DOGE']
TIME Ú©Ø±ÙˆFRAMES_TO_ANALYZE = ['5m', '15m', '1h', '4h']
POLL_INTERVAL_SECONDS = 600
SIGNAL_CACHE_TTL_SECONDS = 3600

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(funcName)s] - %(message)s')

# Ù†Ú©ØªÙ‡: Ø¨Ø±Ø§ÛŒ ØªØ¨Ø¯ÛŒÙ„ ØªØ§Ø±ÛŒØ® Ø¨Ù‡ Ø´Ù…Ø³ÛŒØŒ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ jdatetime Ø¨Ø§ÛŒØ¯ Ù†ØµØ¨ Ø¨Ø§Ø´Ø¯.
# pip install jdatetime pytz

class SignalCache:
    def __init__(self, ttl_seconds: int):
        self.cache = {}
        self.ttl = ttl_seconds
    def is_duplicate(self, symbol: str, signal_type: str) -> bool:
        now = time.time()
        if symbol in self.cache:
            last_signal, last_time = self.cache[symbol]
            if signal_type == last_signal and (now - last_time) < self.ttl:
                return True
        return False
    def store(self, symbol: str, signal_type: str):
        self.cache[symbol] = (signal_type, time.time())

# --- âœ¨ ØªØ§Ø¨Ø¹ ÙØ±Ù…Øª Ù¾ÛŒØ§Ù… ØªÙ„Ú¯Ø±Ø§Ù… (Ù†Ø³Ø®Ù‡ Ø§ÙØ³Ø§Ù†Ù‡â€ŒØ§ÛŒ) âœ¨ ---
def format_legendary_message(signal_obj: dict) -> str:
    """ÛŒÚ© Ø¢Ø¨Ø¬Ú©Øª Ø³ÛŒÚ¯Ù†Ø§Ù„ Ú©Ø§Ù…Ù„ Ø±Ø§ Ø¨Ù‡ ÛŒÚ© Ù¾ÛŒØ§Ù… ØªÙ„Ú¯Ø±Ø§Ù… Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ùˆ Ø¬Ø§Ù…Ø¹ ØªØ¨Ø¯ÛŒÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯."""
    
    # Û±. Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù„Ø§Ø²Ù…
    signal_type = signal_obj.get("signal_type", "N/A")
    symbol = signal_obj.get("symbol", "N/A")
    timeframe = signal_obj.get("timeframe", "N/A")
    entry_zone = signal_obj.get("entry_zone", [])
    stop_loss = signal_obj.get("stop_loss", 0.0)
    targets = signal_obj.get("targets", [])
    rr_ratio = signal_obj.get("risk_reward_ratio", 0.0)
    sys_confidence = signal_obj.get("system_confidence_percent", 0)
    ai_confidence = signal_obj.get("ai_confidence_percent", 0)
    reasons = signal_obj.get("reasons", ["Analysis based on internal scoring."])
    issued_at_utc_str = signal_obj.get("issued_at", datetime.utcnow().isoformat())

    # Û². Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ÛŒ
    signal_header = "ğŸŸ¢ LONG" if signal_type == "BUY" else "ğŸ”´ SHORT"
    
    # ÙØ±Ù…Øª Ù…Ø­Ø¯ÙˆØ¯Ù‡ ÙˆØ±ÙˆØ¯
    entry_range_str = f"`{entry_zone[0]:,.4f} - {entry_zone[1]:,.4f}`" if len(entry_zone) > 1 else f"`{entry_zone[0]:,.4f}`"
    
    # ÙØ±Ù…Øª ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§
    targets_str = "\n".join([f"    ğŸ¯ TP{i+1}: `{t:,.4f}`" for i, t in enumerate(targets)])

    # ÙØ±Ù…Øª Ø¯Ù„Ø§ÛŒÙ„
    reasons_str = "\n".join([f"â€¢ _{reason}_" for reason in reasons])
    
    # Û³. ØªØ¨Ø¯ÛŒÙ„ ØªØ§Ø±ÛŒØ® Ùˆ Ø²Ù…Ø§Ù† Ø¨Ù‡ ÙˆÙ‚Øª ØªÙ‡Ø±Ø§Ù†
    try:
        utc_dt = datetime.fromisoformat(issued_at_utc_str.replace('Z', '+00:00'))
        tehran_tz = pytz.timezone("Asia/Tehran")
        tehran_dt = utc_dt.astimezone(tehran_tz)
        jalali_dt = jdatetime.fromgregorian(datetime=tehran_dt)
        timestamp_str = f"â° {jalali_dt.strftime('%Y/%m/%d, %H:%M:%S')}"
    except Exception:
        timestamp_str = ""

    # Û´. Ø³Ø§Ø®Øª Ù¾ÛŒØ§Ù… Ù†Ù‡Ø§ÛŒÛŒ
    message = (
        f"ğŸ”¥ **NEW AI SIGNAL** ğŸ”¥\n\n"
        f"ğŸª™ **{symbol}/USDT**\n"
        f"ğŸ“Š Signal: *{signal_header}*\n"
        f"â³ Timeframe: `{timeframe}`\n\n"
        f"ğŸ¯ Confidence: *{sys_confidence:.1f}%* | ğŸ§  AI Score: *{ai_confidence:.1f}%*\n"
        f"----------------------------------------\n"
        f"ğŸ“ˆ **Entry Range:**\n"
        f"    {entry_range_str}\n\n"
        f"ğŸ¯ **Targets:**\n{targets_str}\n\n"
        f"ğŸ›‘ **Stop Loss:**\n"
        f"    `{stop_loss:,.4f}`\n"
        f"----------------------------------------\n"
        f"ğŸ’¡ **Reasons:**\n{reasons_str}\n\n"
        f"âš ï¸ *Risk Management: Use 2-3% of your capital.*\n"
        f"Generated by AiSignalPro ğŸ¤–\n"
        f"{timestamp_str}"
    )
    return message

async def analyze_symbol(fetcher: ExchangeFetcher, orchestrator: MasterOrchestrator, symbol: str) -> Optional[dict]:
    all_tf_analysis = {}
    timeframes_to_analyze = ['5m', '15m', '1h', '4h']
    tasks = {asyncio.create_task(fetcher.get_first_successful_klines(symbol, tf)): tf for tf in timeframes_to_analyze}
    for task in asyncio.as_completed(tasks):
        tf = tasks[task]
        result = await task
        if result and result[0] is not None:
            df, source = result
            analysis = orchestrator.analyze_single_dataframe(df, tf, symbol)
            analysis['source'] = source
            all_tf_analysis[tf] = analysis
    
    if not all_tf_analysis:
        logging.warning(f"Could not fetch any kline data for {symbol} to perform analysis.")
        return None
    
    final_result = orchestrator.get_multi_timeframe_signal(all_tf_analysis)
    adapter = SignalAdapter(analytics_output=final_result)
    return adapter.combine()

async def monitor_loop():
    telegram = TelegramHandler()
    orchestrator = MasterOrchestrator()
    signal_cache = SignalCache(SIGNAL_CACHE_TTL_SECONDS)
    logging.info("Live Monitoring Worker (Legendary Edition) started successfully.")
    try:
        await telegram.send_message_async("âœ… *Ø±Ø¨Ø§Øª Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯ AiSignalPro (Ù†Ø³Ø®Ù‡ Ø§ÙØ³Ø§Ù†Ù‡â€ŒØ§ÛŒ) ÙØ¹Ø§Ù„ Ø´Ø¯.*")
    except Exception as e:
        logging.error(f"Failed to send initial Telegram message: {e}")
    
    while True:
        logging.info("--- Starting New Monitoring Cycle ---")
        fetcher = ExchangeFetcher()
        try:
            analysis_tasks = [analyze_symbol(fetcher, orchestrator, symbol) for symbol in SYMBOLS_TO_MONITOR]
            results = await asyncio.gather(*analysis_tasks, return_exceptions=True)

            for result in results:
                if isinstance(result, Exception):
                    logging.error(f"An exception occurred during symbol analysis: {result}", exc_info=True)
                elif result and result.get("signal_type") != "HOLD":
                    signal_obj = result
                    symbol = signal_obj["symbol"]
                    signal_type = signal_obj["signal_type"]
                    if not signal_cache.is_duplicate(symbol, signal_type):
                        signal_cache.store(symbol, signal_type)
                        # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ ÙØ±Ù…Øª Ù¾ÛŒØ§Ù…
                        message = format_legendary_message(signal_obj)
                        await telegram.send_message_async(message)
                        logging.info(f"LEGENDARY ALERT SENT for {symbol}: {signal_type}")
                    else:
                        logging.info(f"Duplicate signal '{signal_type}' for {symbol}. Skipping.")

        except Exception as e:
            logging.error(f"A critical error occurred in the main monitoring loop: {e}", exc_info=True)
        finally:
            await fetcher.close()
            
        logging.info(f"Cycle finished. Waiting for {POLL_INTERVAL_SECONDS} seconds.")
        await asyncio.sleep(POLL_INTERVAL_SECONDS)

if __name__ == "__main__":
    try:
        asyncio.run(monitor_loop())
    except KeyboardInterrupt:
        logging.info("Monitoring worker stopped by user.")
