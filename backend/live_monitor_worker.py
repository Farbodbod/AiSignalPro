# live_monitor_worker.py (Ø¨Ø§ Ù‡Ù…Ø§Ù‡Ù†Ú¯ÛŒ Ù†Ù‡Ø§ÛŒÛŒ async)

import asyncio
import os
import django
import logging
import time
from typing import Dict, Optional, List
from datetime import datetime
import pytz
from jdatetime import datetime as jdatetime

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'trading_app.settings')
django.setup()

from core.exchange_fetcher import ExchangeFetcher
from engines.master_orchestrator import MasterOrchestrator
from engines.signal_adapter import SignalAdapter
from engines.telegram_handler import TelegramHandler

SYMBOLS_TO_MONITOR = ['BTC', 'ETH', 'XRP', 'SOL', 'DOGE']
TIME_FRAMES_TO_ANALYZE = ['5m', '15m', '1h', '4h']
POLL_INTERVAL_SECONDS = 600
SIGNAL_CACHE_TTL_SECONDS = 3600

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(funcName)s] - %(message)s')

class SignalCache:
    # ... (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±) ...
    def __init__(self, ttl_seconds: int): self.cache = {}; self.ttl = ttl_seconds
    def is_duplicate(self, symbol: str, signal_type: str) -> bool:
        now = time.time()
        if symbol in self.cache:
            last_signal, last_time = self.cache[symbol]
            if signal_type == last_signal and (now - last_time) < self.ttl: return True
        return False
    def store(self, symbol: str, signal_type: str): self.cache[symbol] = (signal_type, time.time())

def format_legendary_message(signal_obj: dict) -> str:
    # ... (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±) ...
    signal_type = signal_obj.get("signal_type", "N/A"); symbol = signal_obj.get("symbol", "N/A"); timeframe = signal_obj.get("timeframe", "N/A"); entry_zone = signal_obj.get("entry_zone", []); stop_loss = signal_obj.get("stop_loss", 0.0); targets = signal_obj.get("targets", []); sys_confidence = signal_obj.get("system_confidence_percent", 0); ai_confidence = signal_obj.get("ai_confidence_percent", 0); reasons = signal_obj.get("reasons", ["Analysis based on internal scoring."]); issued_at_utc_str = signal_obj.get("issued_at", datetime.utcnow().isoformat()); signal_header = "ğŸŸ¢ LONG" if signal_type == "BUY" else "ğŸ”´ SHORT"; entry_range_str = f"`{entry_zone[0]:,.4f} - {entry_zone[1]:,.4f}`" if len(entry_zone) > 1 else (f"`{entry_zone[0]:,.4f}`" if entry_zone else "N/A"); targets_str = "\n".join([f"    ğŸ¯ TP{i+1}: `{t:,.4f}`" for i, t in enumerate(targets)]); reasons_str = "\n".join([f"â€¢ _{reason}_" for reason in reasons]);
    try: utc_dt = datetime.fromisoformat(issued_at_utc_str.replace('Z', '+00:00')); tehran_tz = pytz.timezone("Asia/Tehran"); tehran_dt = utc_dt.astimezone(tehran_tz); jalali_dt = jdatetime.fromgregorian(datetime=tehran_dt); timestamp_str = f"â° {jalali_dt.strftime('%Y/%m/%d, %H:%M:%S')}"
    except Exception: timestamp_str = ""
    message = f"ğŸ”¥ **NEW AI SIGNAL** ğŸ”¥\n\nğŸª™ **{symbol}/USDT**\nğŸ“Š Signal: *{signal_header}*\nâ³ Timeframe: `{timeframe}`\n\nğŸ¯ Confidence: *{sys_confidence:.1f}%* | ğŸ§  AI Score: *{ai_confidence:.1f}%*\n----------------------------------------\nğŸ“ˆ **Entry Range:**\n    {entry_range_str}\n\nğŸ¯ **Targets:**\n{targets_str}\n\nğŸ›‘ **Stop Loss:**\n    `{stop_loss:,.4f}`\n----------------------------------------\nğŸ’¡ **Reasons:**\n{reasons_str}\n\nâš ï¸ *Risk Management: Use 2-3% of your capital.*\nGenerated by AiSignalPro ğŸ¤–\n{timestamp_str}"; return message

async def analyze_symbol(fetcher: ExchangeFetcher, orchestrator: MasterOrchestrator, symbol: str) -> Optional[dict]:
    all_tf_analysis = {}
    tasks = {asyncio.create_task(fetcher.get_first_successful_klines(symbol, tf)): tf for tf in TIME_FRAMES_TO_ANALYZE}
    for task in asyncio.as_completed(tasks):
        tf = tasks[task]
        result = await task
        if result and result[0] is not None:
            df, source = result
            analysis = orchestrator.analyze_single_dataframe(df, tf, symbol)
            analysis['source'] = source
            all_tf_analysis[tf] = analysis
    if not all_tf_analysis:
        logging.warning(f"Could not fetch any kline data for {symbol} to perform analysis.")
        return None
    
    # --- Ø§ØµÙ„Ø§Ø­ Ø´Ø¯: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² await Ø¨Ø±Ø§ÛŒ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ ØªØ§Ø¨Ø¹ async ---
    final_result = await orchestrator.get_multi_timeframe_signal(all_tf_analysis)
    
    adapter = SignalAdapter(analytics_output=final_result)
    return adapter.combine()

async def monitor_loop():
    # ... (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±) ...
    telegram = TelegramHandler(); orchestrator = MasterOrchestrator(); signal_cache = SignalCache(SIGNAL_CACHE_TTL_SECONDS); fetcher = ExchangeFetcher(); logging.info("Live Monitoring Worker (Stable Connection Edition) started successfully.");
    try: await telegram.send_message_async("âœ… *Ø±Ø¨Ø§Øª Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯ AiSignalPro (Ø§ØªØµØ§Ù„ Ù¾Ø§ÛŒØ¯Ø§Ø±) ÙØ¹Ø§Ù„ Ø´Ø¯.*")
    except Exception as e: logging.error(f"Failed to send initial Telegram message: {e}")
    try:
        while True:
            logging.info("--- Starting New Monitoring Cycle ---");
            try:
                analysis_tasks = [analyze_symbol(fetcher, orchestrator, symbol) for symbol in SYMBOLS_TO_MONITOR]; results = await asyncio.gather(*analysis_tasks, return_exceptions=True)
                for result in results:
                    if isinstance(result, Exception): logging.error(f"An exception occurred during symbol analysis: {result}", exc_info=True)
                    elif result and result.get("signal_type") != "HOLD":
                        signal_obj = result; symbol = signal_obj["symbol"]; signal_type = signal_obj["signal_type"]
                        if not signal_cache.is_duplicate(symbol, signal_type):
                            signal_cache.store(symbol, signal_type); message = format_legendary_message(signal_obj); await telegram.send_message_async(message); logging.info(f"LEGENDARY ALERT SENT for {symbol}: {signal_type}")
                        else: logging.info(f"Duplicate signal '{signal_type}' for {symbol}. Skipping.")
            except Exception as e: logging.error(f"A critical error occurred in the main monitoring loop: {e}", exc_info=True)
            logging.info(f"Cycle finished. Waiting for {POLL_INTERVAL_SECONDS} seconds."); await asyncio.sleep(POLL_INTERVAL_SECONDS)
    finally: await fetcher.close(); logging.info("Fetcher client closed. Monitoring worker shutting down.")

if __name__ == "__main__":
    try: asyncio.run(monitor_loop())
    except KeyboardInterrupt: logging.info("Monitoring worker stopped by user.")
